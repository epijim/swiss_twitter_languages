---
title: "Swiss twitter languages"
output: html_document
---

Packages needed

```{r}
library(streamR)
library(ROAuth)
library(dplyr)
library(ggplot2)

```

Should we get more tweets?

```{r}
rerun_tweet <- FALSE
```

# Get tweets

## Prepare twitter

```{r twittersetup, eval=rerun_tweet}
# urls (straight from streamR docs)
requestURL <- "https://api.twitter.com/oauth/request_token"
accessURL <- "https://api.twitter.com/oauth/access_token"
authURL <- "https://api.twitter.com/oauth/authorize"

# I store all my apikeys in one place
source("~/.apikeys/twitter_keys")

# set up an oauth
my_oauth <- OAuthFactory$new(
  consumerKey = twitter_consumer_key, 
  consumerSecret = twitter_consumer_secret, 
  requestURL = requestURL, 
  accessURL = accessURL, 
  authURL = authURL)

# get the oauth
my_oauth$handshake(
  cainfo = system.file("CurlSSL", "cacert.pem", 
                       package = "RCurl")
  )

# save it (and make sure to add this to .gitignore)
save(my_oauth, file = "keys/my_oauth.Rdata")
```

## Get tweets

Now I will open a connection and for the set timeout time, scrape tweets. The bounding box for Switzerland was pulled from an [online repo of country bounding boxes](https://gist.github.com/graydon/11198540).

```{r tweetsource, eval=rerun_tweet}
load("keys/my_oauth.Rdata")

filterStream(
  #  If the file already exists, tweets will be appended (not overwritten).
  "data/tweetsSwiss.json", 
  locations = c(6.02260949059, 45.7769477403, 10.4427014502, 47.8308275417), 
  timeout = 600, 
  oauth = my_oauth)

```

# Analyse

## Load

```{r}

df_tweets <- rbind(
  parseTweets("data/tweetsSwiss.json", verbose = TRUE),
  parseTweets("data/tweetsSwiss_part2.json", verbose = TRUE)
)

```

## Clean

```{r clean}
df_tweets_ch <- df_tweets %>%
  mutate(
    language = case_when(
      .$lang %in% c(
        "en","en-gb","en-GB"
      ) ~ "English",
      .$lang == "de" ~ "Deutsch",
      .$lang == "it" ~ "Italian",
      .$lang == "fr" ~ "French",
      .$lang == "und" ~ "Unknown",
      TRUE ~ "Other"
    ),
    user_language = case_when(
      .$user_lang %in% c(
        "en","en-gb","en-GB"
      ) ~ "English",
      .$user_lang == "de" ~ "Deutsch",
      .$user_lang == "it" ~ "Italian",
      .$user_lang == "fr" ~ "French",
      .$user_lang == "und" ~ "Unknown",
      TRUE ~ "Other"
    )
  ) %>%
  filter(
    country_code == "CH"
  )
```

## Summary

```{r summary}
jb_percent <- function(x){paste0(format(x, big.mark = ",")," (",round(100*x/sum(x)),"%)")}

# Tweets
left_join(
  df_tweets_ch %>%
    group_by(user_language) %>%
    summarise(
      Users = n_distinct(screen_name)
      ) %>%
    arrange(-Users) %>%
    mutate(`Users` = jb_percent(Users)),
  df_tweets_ch %>%
    group_by(language) %>%
    summarise(
      Tweets = n()
      ) %>%
    mutate(Tweets = jb_percent(Tweets)),
  by = c("user_language" = "language")
) %>% rename(Language = user_language) %>%
  knitr::kable(
    caption = "Count of users and tweets (users refers to language the user has enabled in twitter, tweets is based off language of each individual tweet)."
  )

# Who tweets in different language from website setting
# do median proportio
df_tweets_ch %>%
  # remove unknown (usually links)
  filter(language != "Unknown") %>%
  mutate(
    wronglang = ifelse(user_language != language,T,F)
  ) %>%
  group_by(user_language,screen_name) %>%
  summarise(
    wronglang = sum(wronglang),
    `Wrong language` = sum(wronglang > 0)
  ) %>%
  group_by(user_language,`Wrong language`) %>%
  summarise(
    `Count` = n()
  ) %>%
  mutate(Count = round(100*Count/sum(Count))) %>%
  arrange(-Count) %>%
  mutate(`Count` = paste0(Count,"%")) %>%
  ungroup() %>%
  rename(
    `UI language` = user_language
  ) %>% filter(`Wrong language` == 1) %>%
  select(`UI language`, Count) %>%
  knitr::kable(
    caption = "Proportion of twitter users that have tweeted in a language other than their website setting."
  )

# And what language do they tweet?
df_tweets_ch %>%
  filter(
    user_language != language
  ) %>%
  group_by(user_language, language) %>%
  summarise(
    Count = n_distinct(screen_name)
    ) %>%
  arrange(-Count) %>%
  rename(
    `Twitter setting` = user_language,
    `Tweet language` = language
  ) %>%
  mutate(`Count` = jb_percent(Count))




# swiss 
df_tweets %>% filter(country_code == "CH") %>% nrow()

df_tweets %>% 
  group_by(country_code, lang) %>%
  summarise(
    n = n(),
    n_users = n_distinct(user_id_str)
  ) %>%
  mutate(
    `% of users` = round(100*n_users/sum(n_users),1)
  ) %>%
  arrange(country_code, -n_users) %>%
  DT::datatable()

df_tweets %>% 
  filter(country_code == "CH") %>%
  group_by(lang) %>%
  summarise(
    n = n(),
    n_users = n_distinct(user_id_str)
  ) %>%
  mutate(
    `% of tweets` = round(100*n/sum(n),1),
    `% of users` = round(100*n_users/sum(n_users),1)
  ) %>%
  arrange(-n_users) %>%
  DT::datatable()
  
```

# Prep data

```{r}
df_tweets <- df_tweets %>%
  mutate(
    language = case_when(
      .$user_lang %in% c(
        "en","en-gb","en-GB"
      ) ~ "English",
      .$user_lang == "de" ~ "Deutsch",
      .$user_lang == "it" ~ "Italian",
      .$user_lang == "fr" ~ "French",
      .$user_lang == "und" ~ "Unknown",
      TRUE ~ "Other"
    )
  )
```

# Map data

```{r getmap}
d_ch <- raster::getData("GADM", country="CH", level=0)

p_ch <- sp::spTransform(d_ch, CRS("+init=EPSG:32737")) 

# convert data
df_plotdata <- df_tweets %>%
  select(
    lon = place_lon,
    lat = place_lat,
    country_code,
    screen_name,
    Language = language
  ) %>%
  na.omit

coordinates(df_plotdata) <- 1:2
proj4string(df_plotdata) <- CRS("+proj=longlat +datum=WGS84")  
df_plotdata <- sp::spTransform(df_plotdata, CRS("+init=EPSG:32737")) 

df_plotdata <- as.data.frame(df_plotdata) %>%
      filter(country_code == "CH" & Language %in% 
               c("Deutsch","English","French","Italian"))

# Blank theme
new_theme_empty <- theme_bw()
new_theme_empty$line <- element_blank()
new_theme_empty$rect <- element_blank()
new_theme_empty$strip.text <- element_blank()
new_theme_empty$axis.text <- element_blank()
#new_theme_empty$plot.title <- element_blank()
new_theme_empty$axis.title <- element_blank()
new_theme_empty$plot.margin <- structure(c(0, 0, -1, -1), unit = "lines", valid.unit = 3L, class = "unit")

ggplot() + 
  geom_polygon(data=p_ch, aes(long,lat,group=group), fill="whitesmoke") +
  geom_path(
    data=p_ch, 
    aes(long,lat, group=group), 
    color="grey",
    size=0.1) +
  geom_point(
    data = df_plotdata,
    aes(
      x = lon, y = lat, colour = Language #, shape = Language
      ),
    alpha = 0.5
  ) +
  scale_colour_manual(
    values = c(
      Deutsch = "#ff0000",
      English = "#808080",
      French = "#0000ff",
      Italian = "#009900"
    )
    )

# Plot!

# Create a bounding box 10% bigger than the bounding box of London
# http://stackoverflow.com/questions/21286643/ggplot2-gis-plotting-inside-polygon-area
x_excess = (p_ch@bbox['x','max'] - p_ch@bbox['x','min'])*0.1
y_excess = (p_ch@bbox['y','max'] - p_ch@bbox['y','min'])*0.1
x_min = p_ch@bbox['x','min'] - x_excess
x_max = p_ch@bbox['x','max'] + x_excess
y_min = p_ch@bbox['y','min'] - y_excess
y_max = p_ch@bbox['y','max'] + y_excess
bbox = matrix(c(x_min,x_max,x_max,x_min,x_min,
                y_min,y_min,y_max,y_max,y_min),
              nrow = 5, ncol =2)
bbox = Polygon(bbox, hole=FALSE)
bbox = Polygons(list(bbox), "bbox")
bbox = SpatialPolygons(Srl=list(bbox), pO=1:1, proj4string=p_ch@proj4string)

# Get the Polygon that is the difference between the bounding box and London
outside = rgeos::gDifference(bbox,p_ch)
outside = fortify(outside)

jb_plot <- function(Language_filter = "English"){
  ggplot() + 
  geom_polygon(
    data=p_ch, 
    aes(x=long,y=lat,group=group), 
    fill="black") +
  stat_bin2d(
    data=df_plotdata %>%
      filter(Language %in% c(Language_filter)), 
    aes(x=lon,y=lat), 
    bins=40) +
  geom_path(data=p_ch, aes(x=long,y=lat,group=group), colour='white') +
  geom_polygon(data=outside, aes(x=long,y=lat), fill='white') +
  coord_equal() +
  new_theme_empty +
  theme(
    panel.background = element_rect(fill='black', colour='black'),
    legend.position = "none"
    ) +
  labs(title = paste(Language_filter,"tweet distribution"))
}

jb_plot("English")
jb_plot("French")
jb_plot("Deutsch")
jb_plot("Italian")
```

